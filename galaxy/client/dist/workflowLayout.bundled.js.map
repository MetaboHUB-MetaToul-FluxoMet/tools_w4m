{"version":3,"file":"workflowLayout.bundled.js","mappings":"sOAAIA,EAAwC,SAAUC,EAASC,EAAYC,EAAGC,GAE1E,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUC,GAAS,IAAMC,EAAKN,EAAUO,KAAKF,GAAS,CAAE,MAAOG,GAAKL,EAAOK,EAAI,CAAE,CAC1F,SAASC,EAASJ,GAAS,IAAMC,EAAKN,EAAiB,MAAEK,GAAS,CAAE,MAAOG,GAAKL,EAAOK,EAAI,CAAE,CAC7F,SAASF,EAAKI,GAJlB,IAAeL,EAIaK,EAAOC,KAAOT,EAAQQ,EAAOL,QAJ1CA,EAIyDK,EAAOL,MAJhDA,aAAiBN,EAAIM,EAAQ,IAAIN,GAAE,SAAUG,GAAWA,EAAQG,EAAQ,KAIjBO,KAAKR,EAAWK,EAAW,CAC7GH,GAAMN,EAAYA,EAAUa,MAAMhB,EAASC,GAAc,KAAKS,OAClE,GACJ,EAKA,MAAMO,EAAM,IAAI,KACT,SAASC,EAAWC,EAAIC,GAC3B,IAAIC,EACJ,OAAOtB,EAAUuB,UAAM,OAAQ,GAAQ,YACnC,MAAMC,GAAkB,QAAmBJ,GACrCK,GAAa,OAAsBL,GAEnCM,EAAW,CACbN,GAAI,GACJO,cAAe,CACX,gBAAiB,UACjB,uCAAwC,OACxC,yBAA0B,mBAE9BC,SAAU,GACVC,MAAO,IAEXH,EAASE,SAAWE,OAAOC,QAAQV,GAAOW,KAAI,EAAEC,EAAQvB,MACpD,MAAMwB,EAASJ,OAAOK,OAAOzB,EAAKwB,QAAQF,KAAKI,IACpC,CACHhB,GAAI,GAAGa,QAAaG,EAAMC,OAC1BC,WAAY,CACR,YAAa,OACb,aAAc5B,EAAKU,QAIzBmB,EAAUT,OAAOK,OAAOzB,EAAK6B,SAASP,KAAKQ,IACtC,CACHpB,GAAI,GAAGa,SAAcO,EAAOH,OAC5BC,WAAY,CACR,YAAa,OACb,aAAc5B,EAAKU,QAIzBqB,EAAWhB,EAAWiB,aAAahC,EAAKU,IAE9C,OADA,QAAcqB,EAAU,gCAAgC/B,EAAKU,kCACtD,CACHA,GAAIa,EACJU,OAAQF,EAASE,OAAS,GAC1BC,MAAOH,EAASG,MAAQ,GACxBC,MAAOX,EAAOY,OAAOP,GACxB,IAELb,EAASG,MAAQL,EAAgBuB,YAAYf,KAAKgB,IACjC,CACT5B,GAAI,KAAK4B,EAAWZ,MAAMH,UAAUe,EAAWR,OAAOP,SACtDgB,QAAS,CAAC,GAAGD,EAAWR,OAAOP,cAAce,EAAWR,OAAOH,QAC/Da,QAAS,CAAC,GAAGF,EAAWZ,MAAMH,aAAae,EAAWZ,MAAMC,YAIpE,IACI,MAAMc,QAAgBjC,EAAIkC,OAAO1B,GAMjC,OAJ6C,QAA3BJ,EAAK6B,EAAQvB,gBAA6B,IAAPN,OAAgB,EAASA,EAAGU,KAAKqB,GAClEvB,OAAOwB,OAAOxB,OAAOwB,OAAO,CAAC,EAAGjC,EAAMgC,EAAEjC,KAAM,CAAEqB,SAAU,CAAEc,IAAKF,EAAEG,EAAGC,KAAMJ,EAAEK,MAItG,CACA,MAAOC,GACHC,QAAQD,MAAMA,EAClB,CACJ,GACJ,C","sources":["webpack://@galaxyproject/galaxy-client/./src/components/Workflow/Editor/modules/layout.ts"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport ELK from \"elkjs/lib/elk.bundled.js\";\nimport { useConnectionStore } from \"@/stores/workflowConnectionStore\";\nimport { useWorkflowStateStore } from \"@/stores/workflowEditorStateStore\";\nimport { assertDefined } from \"@/utils/assertions\";\nconst elk = new ELK();\nexport function autoLayout(id, steps) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n        const connectionStore = useConnectionStore(id);\n        const stateStore = useWorkflowStateStore(id);\n        // Convert this to ELK compat.\n        const newGraph = {\n            id: \"\",\n            layoutOptions: {\n                \"elk.algorithm\": \"layered\",\n                \"crossingMinimization.semiInteractive\": \"true\",\n                \"nodePlacement.strategy\": \"NETWORK_SIMPLEX\",\n            },\n            children: [],\n            edges: [],\n        };\n        newGraph.children = Object.entries(steps).map(([stepId, step]) => {\n            const inputs = Object.values(step.inputs).map((input) => {\n                return {\n                    id: `${stepId}/in/${input.name}`,\n                    properties: {\n                        \"port.side\": \"WEST\",\n                        \"port.index\": step.id,\n                    },\n                };\n            });\n            const outputs = Object.values(step.outputs).map((output) => {\n                return {\n                    id: `${stepId}/out/${output.name}`,\n                    properties: {\n                        \"port.side\": \"EAST\",\n                        \"port.index\": step.id,\n                    },\n                };\n            });\n            const position = stateStore.stepPosition[step.id];\n            assertDefined(position, `No StepPosition with step id ${step.id} found in workflowStateStore`);\n            return {\n                id: stepId,\n                height: position.height + 20,\n                width: position.width + 60,\n                ports: inputs.concat(outputs),\n            };\n        });\n        newGraph.edges = connectionStore.connections.map((connection) => {\n            const edge = {\n                id: `e_${connection.input.stepId}_${connection.output.stepId}`,\n                sources: [`${connection.output.stepId}/out/${connection.output.name}`],\n                targets: [`${connection.input.stepId}/in/${connection.input.name}`],\n            };\n            return edge;\n        });\n        try {\n            const elkNode = yield elk.layout(newGraph);\n            // Reapply positions to galaxy graph from our relayed out graph.\n            const newSteps = (_a = elkNode.children) === null || _a === void 0 ? void 0 : _a.map((q) => {\n                const newStep = Object.assign(Object.assign({}, steps[q.id]), { position: { top: q.y, left: q.x } });\n                return newStep;\n            });\n            return newSteps;\n        }\n        catch (error) {\n            console.error(error);\n        }\n    });\n}\n"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","elk","autoLayout","id","steps","_a","this","connectionStore","stateStore","newGraph","layoutOptions","children","edges","Object","entries","map","stepId","inputs","values","input","name","properties","outputs","output","position","stepPosition","height","width","ports","concat","connections","connection","sources","targets","elkNode","layout","q","assign","top","y","left","x","error","console"],"sourceRoot":""}